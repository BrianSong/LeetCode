Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, 
where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.


Solution: ------------------------------------- Backtracking ------------------------ https://www.youtube.com/watch?v=NOfscYKNpqU
-------------------------- O(M * N * 4^L) T, where M*N is the size of the board and we have 4^L for each cell because of the recursion
-------------------------- O(n) S where n is the total element number inside the board
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        if not board or not word:
            return False
        self.dirs = [[1, 0], [-1, 0], [0, 1], [0, -1]]
        self.visited = [[False for j in range(len(board[0]))] for i in range(len(board))]    # A visited list is created for:
                                                                                # "The same letter cell may not be used more than once."
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.backtracking(board, word, i, j):                    # Use every element in the board as a start point for trying
                    return True
        return False
    
    def backtracking(self, board, word, i, j):
        if len(word) == 0:
            return True
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or self.visited[i][j] or board[i][j] != word[0]:
            return
        self.visited[i][j] = True
        for dir in self.dirs:
            if self.backtracking(board, word[1:], i + dir[0], j + dir[1]):   # use "if" to check that as long as one of the four
                                                                             # is returning True, we can return True directly
                return True
        self.visited[i][j] = False                                           # If all not satisfied, erase the trace and return False
                                                                             # actually we can just do nothing rather than return False
                                                                             # Only when all is False, this cell is False
                                                                             # The True or False of this cell will be utilized by
                                                                             # the if statement in the upper recursion level
                                                                             # Since the trace will be erased, we do not need to reset
                                                                             # self.visited everytime 
