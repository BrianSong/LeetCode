Given a 2D board and a word, find if the word exists in the grid.

The word can be constructed from letters of sequentially adjacent cell, 
where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.

Example:

board =
[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]

Given word = "ABCCED", return true.
Given word = "SEE", return true.
Given word = "ABCB", return false.


Solution: ------------------------------------- Backtracking ------------------------ https://www.youtube.com/watch?v=NOfscYKNpqU
class Solution(object):
    def exist(self, board, word):
        """
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        """
        visited = [[False for j in range(len(board[0]))] for i in range(len(board))]    # A visited list is created for:
                                                                                # "The same letter cell may not be used more than once."
        for i in range(len(board)):
            for j in range(len(board[0])):
                if self.backtracking(board, word, visited, 0, i, j):   # Use every element in the board as a start point for trying
                    return True
        return False
                
    def backtracking(self, board, word, visited, index, row, col):
        if index == len(word): return True                             # Pass all, return True
        if row < 0 or row >= len(board) or col < 0  or col >= len(board[0]) or visited[row][col] or board[row][col] != word[index]:
            return False                            
        visited[row][col] = True
        if self.backtracking(board, word, visited, index + 1, row + 1, col):  # DOWN
            return True                                                       # As long as one is satisfied, return immediately,
                                                                              # No need to try the rest directions
                                                                              # As long as one direction is True, this curr cell is True
        if self.backtracking(board, word, visited, index + 1, row, col + 1):  # RIGHT
            return True
        if self.backtracking(board, word, visited, index + 1, row - 1, col):  # UP
            return True
        if self.backtracking(board, word, visited, index + 1, row, col - 1):  # LEFT
            return True
        visited[row][col] = False                                             # If all not satisfied, erase the trace and return False
                                                                              # Only when all is False, this cell is False
                                                                              # The True or False of this cell will be utilized by
                                                                              # the if statement in the upper recursion level
        return False
