Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.

The same repeated number may be chosen from candidates unlimited number of times.

Note:

All numbers (including target) will be positive integers.
The solution set must not contain duplicate combinations.
Example 1:

Input: candidates = [2,3,6,7], target = 7,
A solution set is:
[
  [7],
  [2,2,3]
]
Example 2:

Input: candidates = [2,3,5], target = 8,
A solution set is:
[
  [2,2,2,2],
  [2,3,3],
  [3,5]
]

Solution:
class Solution(object):
    def combinationSum(self, candidates, target):
        res = []
        clist = []
        self.comb_help(sorted(candidates), target, clist, res) # Need to be sorted first
        return res
        """
        :type candidates: List[int]
        :type target: int
        :rtype: List[List[int]]
        """
    def comb_help(self, candidates, target, clist, res):
        
        for item in candidates:
            if item > target:
                break                 # The reason to break here: the candidates list is already sorted from smallest to largest,
                                      # if adding this item is not working, all other items should not be considered at this level of 
                                      # recursion, so, use break statement to jump backward twice
            clist.append(item) # just append the item beforehead since all other situations all contain pop()
            if item == target:
                res.append(clist[:])  # Use [:] 
                clist.pop()           # Better to use pop() here because there is a break statement below, if use pop() later, this 
                                      # pop() will not be excuated.
                break                 # break is applied here for the same reason as stated above
            if item < target:
                curridex = candidates.index(item)
                self.comb_help(candidates[curridex:], target-item, clist, res)
                clist.pop()           # Formal standard for backtracking problem, have a currlist and curridex and pop() after the 
                                      # recursion function
                
                
             
