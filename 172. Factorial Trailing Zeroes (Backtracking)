Given an integer n, return the number of trailing zeroes in n!.

Example 1:

Input: 3
Output: 0
Explanation: 3! = 6, no trailing zero.
Example 2:

Input: 5
Output: 1
Explanation: 5! = 120, one trailing zero.
Note: Your solution should be in logarithmic time complexity.

Solution:
'''
All trailing 0 is from factors 5 * 2.
sometimes one number may have several 5 factors, 
for example, 25 have two 5 factors, 125 have three 5 factors. In the n! operation, factors 2 is always ample. 
So we just count how many 5 factors in all number from 1 to n.

Example:
How many multiples of 5 are there in the numbers from 1 to 100?

because 100 ÷ 5 = 20, so, there are twenty multiples of 5 between 1 and 100.

but wait, actually 25 is 5×5, so each multiple of 25 has an extra factor of 5, e.g. 25 × 4 = 100，which introduces extra of zero.

So, we need know how many multiples of 25 are between 1 and 100? Since 100 ÷ 25 = 4, there are four multiples of 25 between 1 and 100.

Finally, we get 20 + 4 = 24 trailing zeroes in 100!

The above example tell us, we need care about 5, 5×5, 5×5×5, 5×5×5×5 ....
'''
class Solution(object):
    def trailingZeroes(self, n):
        return 0 if n == 0 else n / 5 + self.trailingZeroes(n / 5)
        '''
        return 0 if n == 0 ------- Base case
        n / 5 is for normal case, for example, 23!: 5, 10, 15, 20 -> 4
        why self.trailingZeroes(n / 5)?
        because for 25, 125, 25 * 2 * 2 = 100 -> 2's 0; 125 * 2 * 2 * 2 = 1000 -> 3's 0
        25 自己已经计算了一次0， 但是它本身还有factor 5 可以再计算一次
        125 自己已经计算了一次0， 但是它本身还有factor 25 可以继续往下拆分
        So, recursion is needed
        '''
        """
        :type n: int
        :rtype: int
        """
