Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

Example:

Input: [-2,1,-3,4,-1,2,1,-5,4],
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
Follow up:

If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle.

Solution no.1: DP
class Solution(object):
    def maxSubArray(self, nums):
        if max(nums) < 0:
            return max(nums)
        local_max, global_max = 0, 0
        for num in nums:
            local_max = max(0, local_max + num)         # Keep updating  只要大于零，就是值得保留的
            global_max = max(local_max, global_max)     # Keep updating  在所有大于零的subset中选出最大的作为result
        return global_max
        """
        :type nums: List[int]
        :rtype: int
        """
        
        
Solution no.2: Divide and Conquer
'''
Divide and Conquer
3 steps:
1. 把一个大问题分解为许多个小的，独立的，解决方法相同的小问题
2. 在当前的小问题的规模足够小的时候，就地解决 (Boundary Condition), 如果不够小，则继续分解
3. 合并结果
'''
'''
1) Divide the given array in two halves
2) Return the maximum of following three
….a) Maximum subarray sum in left half (Make a recursive call)
….b) Maximum subarray sum in right half (Make a recursive call)
….c) Maximum subarray sum such that the subarray crosses the midpoint
'''
class Solution(object):
    def maxSubArray(self, nums):

        
        return self.maxSubArrayhelp(nums, 0, len(nums) - 1)
        
        """
        :type nums: List[int]
        :rtype: int
        """
    def maxSubArrayCrossing(self, nums, middle, left, right):
        
        currmax , left_max = 0, -float('inf')
        for i in range(middle, left - 1, -1):
            currmax += nums[i]
            if currmax > left_max:
                left_max = currmax
            
        currmax , right_max = 0, -float('inf')
        for i in range(middle + 1, right + 1, 1):
            currmax += nums[i]
            if currmax > right_max:
                right_max = currmax
        return left_max + right_max
        
        
    def maxSubArrayhelp(self, nums, left, right):
        if left == right:
            return nums[left]
        middle = (left + right) / 2
        return max(self.maxSubArrayhelp(nums, left, middle), self.maxSubArrayhelp(nums, middle + 1, right), self.maxSubArrayCrossing(nums, middle, left, right))
        
