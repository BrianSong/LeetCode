Calculate the sum of two integers a and b, but you are not allowed to use the operator + and -.

Example 1:

Input: a = 1, b = 2
Output: 3
Example 2:

Input: a = -2, b = 3
Output: 1

Solution: --------------------- https://www.youtube.com/watch?time_continue=139&v=qq64FrA2UXQ (works for both positive)
----------------------------------------------------------------- O(1) T, O(1) S
'''
For this, problem, for example, we have a = 1, b = 3,

In bit representation, a = 0001, b = 0011,

First, we can use "and"("&") operation between a and b to find a carry.

carry = a & b, then carry = 0001

Second, we can use "xor" ("^") operation between a and b to find the different bit, and assign it to a,

Then, we shift carry one position left and assign it to b, b = 0010.

Iterate until there is no carry (or b == 0)

IDEALY,
let's try for a = 46, b = -14

46 = 101110
14 = 001110
-14 = 1's complement of (14) + 1 ( 1's complement = invert all bits)
so -14 = 110001
1 (+)
110010

so now all we have to do is add 46 and -14

46 = 101110
-14 = 110010 (+)
we get 100000 (which is 32 )

Note : we don't have to do the two's complement, the negative number will be already represented in two's complement.

HOWEVER, In python: the recursion will not end given input a=1, b=-1, as a and b just keeping increasing. => TLE ERROR

The issue is due to the way python performs left shift on negative numbers. 

Python 3 has arbitrary-precision integers ("bignums"). 
This means that anytime x is negative, x << 1 will make x a negative number with twice the magnitude. 
Zeros shifting in from the right will just push the number larger and larger.

In two's complement, positive numbers have a 0 in the highest bit and negative numbers have a 1 in the highest bit. 
That means that, when only one of a and b is negative, the top bits of a and b will differ. 
Therefore, x will be positive (1 & 0 = 0) and y will be negative (1 ^ 0 = 1). 
Thus the new a will be positive (x<<1) and the new b will be negative (y).

Now: arbitrary-precision negative integers actually have an infinite number of leading 1 bits, at least mathematicallly. 
So a is a larger and larger positive number, expanding by 2 each iteration.  
b keeps getting more and more leading 1 bits added to be able to carry out the bitwise & and ^ with  a. 
Thus whatever bits of a are turned on line up with one of the added 1 bits of b, so a & b is always true, so the loop runs forever.

For example, a = 4, b = -3:
in each iteration, print bin(a) and bin(b), the results are:
-0b111 0b1000
-0b1111 0b10000
-0b11111 0b100000
-0b111111 0b1000000
-0b1111111 0b10000000
-0b11111111 0b100000000
-0b111111111 0b1000000000
-0b1111111111 0b10000000000
-0b11111111111 0b100000000000
-0b111111111111 0b1000000000000
-0b1111111111111 0b10000000000000
-0b11111111111111 0b100000000000000
-0b111111111111111 0b1000000000000000
-0b1111111111111111 0b10000000000000000
-0b11111111111111111 0b100000000000000000
-0b111111111111111111 0b1000000000000000000
-0b1111111111111111111 0b10000000000000000000
-0b11111111111111111111 0b100000000000000000000
-0b111111111111111111111 0b1000000000000000000000
-0b1111111111111111111111 0b10000000000000000000000
-0b11111111111111111111111 0b100000000000000000000000
-0b111111111111111111111111 0b1000000000000000000000000
-0b1111111111111111111111111 0b10000000000000000000000000
-0b11111111111111111111111111 0b100000000000000000000000000
-0b111111111111111111111111111 0b1000000000000000000000000000
-0b1111111111111111111111111111 0b10000000000000000000000000000
-0b11111111111111111111111111111 0b100000000000000000000000000000
-0b111111111111111111111111111111 0b1000000000000000000000000000000
-0b1111111111111111111111111111111 0b10000000000000000000000000000000
-0b11111111111111111111111111111111 0b100000000000000000000000000000000
-0b111111111111111111111111111111111 0b1000000000000000000000000000000000
-0b1111111111111111111111111111111111 0b10000000000000000000000000000000000
-0b11111111111111111111111111111111111 0b100000000000000000000000000000000000
-0b111111111111111111111111111111111111 0b1000000000000000000000000000000000000
-0b1111111111111111111111111111111111111 0b10000000000000000000000000000000000000
-0b11111111111111111111111111111111111111 0b100000000000000000000000000000000000000
-0b111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000000000000000
-0b11111111111111111111111111111111111111111111111111111111111111 0b100000000000000000000000000000000000000000000000000000000000000
-0b111111111111111111111111111111111111111111111111111111111111111 0b1000000000000000000000000000000000000000000000000000000000000000
-0b1111111111111111111111111111111111111111111111111111111111111111 0b10000000000000000000000000000000000000000000000000000000000000000
....................................................
Nonstop => TLE ERROR
'''
class Solution(object):
    def getSum(self, a, b):
        """
        :type a: int
        :type b: int
        :rtype: int
        """
        mask = 0xFFFFFFFF                   # Therefore, we introduce a mask 0xFFFFFFFF
                                            # bin(mask) = 0b11111111111111111111111111111111
                                            # mask to get last 32 bits
        
        while not b == 0:
            carry = a & b
            a = (a^b) & mask                # Use mask to & (a ^ b) and (carry << 1) will contain these two in 32 bits
            b = (carry << 1) & mask
       
        if a > 2**31:                       # if a is negative, get a's 32 bits complement positive first
                                            # then get 32-bit positive's Python complement negative
                                            # For exampel, if a == -4
                                            # bin(a) => 0b11111111111111111111111111111100
                                            # bin(a^mask) => 0b11
                                            # bin(~(a^mask)) => -0b100  (~ operator just change 0b to -0b and add 1 to the latter bits)
            return ~(a^mask)
        
        else:
            return a
