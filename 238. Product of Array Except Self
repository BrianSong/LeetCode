Given an array nums of n integers where n > 1,  return an array output such that output[i] is equal to the product of all the elements of nums except nums[i].

Example:

Input:  [1,2,3,4]
Output: [24,12,8,6]
Note: Please solve it without division and in O(n).

Solution:
1. Naive version and rejected:
class Solution(object):
    def productExceptSelf(self, nums):
        output = [1] * len(nums)
        for index_1, item_1 in enumerate(output):
            for index_2, item_2 in enumerate(nums):
                if index_2 == index_1:
                    pass
                else:
                    item_1 *= item_2
                    output[index_1] = item_1
        return output
'''
This method actually worked and return the correct output
However, the question asks us to solve in O(n).
This method using one for loop inside another for loop, so the time complexity is O(n^2)
So, what should we do to have a O(n)?
Maybe two for loop side by side? O(2n) can be approximated to O(n)
'''
2. Accpected version with O(n):
class Solution(object):
    def productExceptSelf(self, nums):
        output = [1] * len(nums)
        prod = 1
        for i in range(len(nums)): # Multiple all elements in nums before this element in output (the same order index)
            output[i] *= prod
            prod *= nums[i] # Multiple prod in the later step can make sure the output[i] multiple the element before it
        prod = 1
        for i in range(len(nums) - 1, -1, -1):# Multiple all elements after this element
            '''
            Select len(nums) - 1 because the last element's index in nums[] is len(nums) - 1
            the last -1 means decrement
            '''
            output[i] *= prod
            prod *= nums[i]
        return output
