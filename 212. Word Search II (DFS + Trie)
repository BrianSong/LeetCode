Given a 2D board and a list of words from the dictionary, find all words in the board.

Each word must be constructed from letters of sequentially adjacent cell, 
where "adjacent" cells are those horizontally or vertically neighboring. 
The same letter cell may not be used more than once in a word.

 

Example:

Input: 
board = [
  ['o','a','a','n'],
  ['e','t','a','e'],
  ['i','h','k','r'],
  ['i','f','l','v']
]
words = ["oath","pea","eat","rain"]

Output: ["eat","oath"]
 

Note:

All inputs are consist of lowercase letters a-z.
The values of words are distinct.


Solution no.1: ------------------------------------- DFS as in Leetcode no.79. Word Search ---- Pass 34/36 but TLE error
------------------------------------------- O(m*n*l*(4^wl)) T, l is the word number, wl is the average length of each word
------------------------------------------- O(wl) S
class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        visited = [[False for j in range(len(board[0]))] for i in range(len(board))]
        res = []
        for word in words:
            for i in range(len(board)):
                for j in range(len(board[0])):
                    self.dfs(board, word, visited, res, "", 0, i, j)
        return res
    
    
    def dfs(self, board, word, visited, res, currpath, idx, row, col):
        if idx == len(word) and not currpath in res:
            res.append(currpath[:])
            return
        if idx == len(word):
            return
        if row < 0 or row >= len(board) or col < 0  or col >= len(board[0]) or visited[row][col] or board[row][col] != word[idx]:
            return
        visited[row][col] = True
        self.dfs(board, word, visited, res, currpath + board[row][col], idx + 1, row + 1, col)
        self.dfs(board, word, visited, res, currpath + board[row][col], idx + 1, row, col + 1)
        self.dfs(board, word, visited, res, currpath + board[row][col], idx + 1, row - 1, col)
        self.dfs(board, word, visited, res, currpath + board[row][col], idx + 1, row, col - 1)
        visited[row][col] = False
        

Solution no.2: --------------------------------------------------- Trie
--------------------------------------------------- O(m*n*wl*(4^wl)) T, wl is the average length of each word
------ Space: O(l * wl) = max(O(wl), O(l * wl)) where
------ O(wl) - The recursive stack can grow at most to wl layers. 
------ O(l * wl) - In the worst case when all words start with different characters, the trie has l * wl nodes. Also, since each 
------ word is stored in a leaf node, all the leaf nodes require l * wl memory.
'''
Simple backtracking cannot pass the larger test. We must stop backtracking earlier.
If the current candidate does not exist in all words' prefix, we could stop backtracking immediately. => Trie
'''
class TrieNode(object):
    def __init__(self): 
        self.children = collections.defaultdict(TrieNode)      # Here (TrieNode) instead of (TrieNode())
        self.isEnd = False

class Trie(object):
    def __init__(self):
        self.root = TrieNode()                                 # Here self.root = TrieNode() instead of self.root = TrieNode
    
    def insert(self, word):
        curr = self.root
        for c in word:
            curr = curr.children[c]
        curr.isEnd = True
    
        
class Solution(object):
    def findWords(self, board, words):
        """
        :type board: List[List[str]]
        :type words: List[str]
        :rtype: List[str]
        """
        if not board or not words:
            return None
        res = []
        trie = Trie()                                          # Create a trie data structure
        for word in words:
            trie.insert(word)
        node = trie.root                                       # node here is kind of like a dummynode in linked list
        self.dirs = [[1, 0], [0, 1], [0, -1], [-1, 0]]
        for i in range(len(board)):
            for j in range(len(board[0])):
                self.backtracking(board, node, i, j, "", res)
        return res
    
    def backtracking(self, board, node, i, j, curr, res):
        if node.isEnd:
            res.append(curr)
            node.isEnd = False                                 # Set node.isWord to false is to de-duplicate
            return                                             # and pass cases like [aaa, aaab]
        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or not board[i][j] in node.children:
            return
        temp = board[i][j]
        board[i][j] = '#'                                      # Set board[i][j] to '#' serves as a visited purpose
                                                               # so that we will not use extra space for visited matrix
        for dir in self.dirs:
            self.backtracking(board, node.children[temp], i + dir[0], j + dir[1], curr + temp, res)
        board[i][j] = temp
