Shuffle a set of numbers without duplicates.

Example:

// Init an array with set 1, 2, and 3.
int[] nums = {1,2,3};
Solution solution = new Solution(nums);

// Shuffle the array [1,2,3] and return its result. Any permutation of [1,2,3] must equally likely to be returned.
solution.shuffle();

// Resets the array back to its original configuration [1,2,3].
solution.reset();

// Returns the random shuffling of array [1,2,3].
solution.shuffle();


Solution no.1: ------------------------------------- Brute Force => O(n^2) time, O(n) space
'''
The correctness of the algorithm follows from the fact that an element (without loss of generality) 
is equally likely to be selected during all iterations of the for loop.
See detailed proof in the original attached solution.
'''
class Solution(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.array = nums
        self.original = list(nums)                               

    def reset(self):
        """
        Resets the array to its original configuration and return it.
        :rtype: List[int]
        """
        self.array = self.original
        self.original = list(self.original)
        return self.array
    
    def shuffle(self):
        """
        Returns a random shuffling of the array.
        :rtype: List[int]
        """
        aux = list(self.array)                                                 # Why use list() ? 
                                                                               # In python, = means direct assignment, 
                                                                               # if we let aux = self.array, instead of putting a list()
                                                                               # When aux.pop(), self.array will also pop()
        for i in range(len(self.array)):
            remove_idx = random.randrange(len(aux))
            self.array[i] = aux.pop(remove_idx)
        return self.array
        
        
Solution no.2: -------------------------------------- Fisher-Yates Algorithm => O(n) time, O(n) space
'''
On each iteration of the algorithm, we generate a random integer between the current index and the last index of the array. 
Then, we swap the elements at the current index and the chosen index - this simulates drawing (and removing) the element from the hat, 
as the next range from which we select a random index will not include the most recently processed one. 
One small, yet important detail is that it is possible to swap an element with itself, 
otherwise, some array permutations would be more likely than others. 
'''
class Solution(object):

    def __init__(self, nums):
        """
        :type nums: List[int]
        """
        self.array = nums
        self.original = list(nums)

    def reset(self):
        """
        Resets the array to its original configuration and return it.
        :rtype: List[int]
        """
        self.array = self.original
        self.original = list(self.original)
        return self.array
    
    def shuffle(self):
        """
        Returns a random shuffling of the array.
        :rtype: List[int]
        """
        for i in range(len(self.array)):
            idx = random.randrange(i, len(self.array))
            self.array[i], self.array[idx] = self.array[idx], self.array[i]
        return self.array
