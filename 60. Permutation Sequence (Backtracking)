The set [1,2,3,...,n] contains a total of n! unique permutations.

By listing and labeling all of the permutations in order, we get the following sequence for n = 3:

"123"
"132"
"213"
"231"
"312"
"321"
Given n and k, return the kth permutation sequence.

Note:

Given n will be between 1 and 9 inclusive.
Given k will be between 1 and n! inclusive.
Example 1:

Input: n = 3, k = 3
Output: "213"
Example 2:

Input: n = 4, k = 9
Output: "2314"

Solution no.1: -------------------------- my own --------------------------- workable but too slow -> Time limit error
class Solution(object):
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        nums = [i for i in range(1, n + 1)]
        self.times = k
        self.res = ""
        self.backtracking(nums, "", n)
        return self.res
        
    def backtracking(self, nums, path, n):
        if len(path) == n:
            self.times -= 1
            if self.times == 0:
                self.res = path
        else:
            for num in nums:
                if not str(num) in path:
                    self.backtracking(nums, path + str(num), n)
                    
Solution no.2: -------------------------------------------------------------- One Pass
class Solution(object):
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        candidate = [str(i) for i in range(1, n + 1)]
        res = ""
        return self.backtracking(n, k, candidate, res)
        
        
    def backtracking(self, n, k, candidate, res):
        if n == 1:
            res += candidate[0]
            return res
        else:
            SameFirstNum = math.factorial(n - 1)            # fix the first number, how many permutations for that number
            idx = (k - 1) / SameFirstNum                    # find the index for first number
            digit = candidate[idx]                          # find the first number
            res += digit
            candidate.remove(digit)                         # remove the first number
            return self.backtracking(n - 1, k % SameFirstNum, candidate, res)  
            # k % SameFirstNum -> small than SameFirstNum
