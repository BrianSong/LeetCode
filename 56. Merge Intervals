Given a collection of intervals, merge all overlapping intervals.

Example 1:

Input: [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].
Example 2:

Input: [[1,4],[4,5]]
Output: [[1,5]]
Explanation: Intervals [1,4] and [4,5] are considered overlapping.
NOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.

Solution: ------------------------------------------------------------------------ my own
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        if len(intervals) == 0:
            return None
        intervals.sort()
        idx = 0
        while idx <= len(intervals) - 2:
            if intervals[idx][0] >= intervals[idx + 1][0] or intervals[idx][1] >= intervals[idx + 1][0]:
                new = [min(intervals[idx][0], intervals[idx + 1][0]), max(intervals[idx][1], intervals[idx + 1][1])]
                intervals[idx] = new
                del intervals[idx + 1]
            else:
                idx += 1
        return intervals
       
Solution no.2: ---------------------------- faster ---------------------------------- https://www.youtube.com/watch?v=0aaCHSYzSVs
class Solution(object):
    def merge(self, intervals):
        """
        :type intervals: List[List[int]]
        :rtype: List[List[int]]
        """
        if len(intervals) == 0:
            return None
        res, start, end, i = [], [], [], 0
        for interval in intervals:
            start.append(interval[0])
            end.append(interval[1])
        start.sort()
        end.sort()
        while i < len(intervals):
            st = start[i]
            while i + 1 <= len(intervals) - 1 and end[i] >= start[i + 1]:
                i += 1
            ed = end[i]
            new = [st, ed]
            res.append(new)
            i += 1
        return res
