Given a binary search tree, write a function kthSmallest to find the kth smallest element in it.

Note: 
You may assume k is always valid, 1 ≤ k ≤ BST's total elements.

Example 1:

Input: root = [3,1,4,null,2], k = 1
   3
  / \
 1   4
  \
   2
Output: 1
Example 2:

Input: root = [5,3,6,2,4,null,null,1], k = 3
       5
      / \
     3   6
    / \
   2   4
  /
 1
Output: 3

Solution: ----------------------------------------------------------- BTS + DFS
--------------------------------------------------------------------- O(n) T, O(n) S
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution(object):
    def kthSmallest(self, root, k):
        self.k = k                    # We can always use global variable inside our function to make the process easier,
                                      # However, we need to keep in mind that, for a big project, global variable may not be a good
                                      # choice, since we will have so many different functions, inside each function, we need to 
                                      # change the local variable's name to avoid repeating the global variable.
                                      # So we may need code with better encapsulation(封装性) for a big project
        self.res = 0
        self.kthsmallest_help(root)
        return self.res
        """
        :type root: TreeNode
        :type k: int
        :rtype: int
        """
    def kthsmallest_help(self, root):
        if root is None:                  # Condition
            return                        # End this level's recursion function and jump up to previous level immediately
        self.kthsmallest_help(root.left)  # Look into the left branch
        self.k = self.k - 1               # Only can reduce k only after the node.left is None (itself is the samllest now)
                                          # or all the left nodes have been transverse (all the node small than it have been counted)
        if self.k == 0:
            self.res = root.val
            return
        self.kthsmallest_help(root.right) # Look into the right branch and repeat the same process,
                                          # Literally no difference between left and right branch
                                          # Remember the characteristic of BTS,
                                          # the smallest node is the leftest node,
                                          # the second smallest node is the leftest node of the right subtree for the leftest node
