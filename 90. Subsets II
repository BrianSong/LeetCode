Given a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).

Note: The solution set must not contain duplicate subsets.

Example:

Input: [1,2,2]
Output:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]

Solution: ------------------------------------------------ https://www.youtube.com/watch?v=rtFHxiQAICA&t=411s
class Solution(object):
    def subsetsWithDup(self, nums):
        if nums is None or len(nums) == 0:                          # Extreme case analyse
            return []
        nums.sort()                                                 # Better sort the nums first
        res = []
        self.helper(nums, 0, True, res, [])
        return res
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
    def helper(self, nums, curridx, taken, res, currlist):          # In order to eliminate the duplicate case,
                                                                    # we introduce a taken argument
        if curridx == len(nums):
            res.append(currlist[:])
        else:
            self.helper(nums, curridx + 1, False, res, currlist)    # Situation 1: not taken
            '''
            Duplicate cases happen when the previous "same" number is not taken and current "same" number is taken
            '''
            if taken or nums[curridx] != nums[curridx - 1]:
                currlist.append(nums[curridx])
                self.helper(nums, curridx + 1, True, res, currlist) # Situation 2: taken
                currlist.pop()
