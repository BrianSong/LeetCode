Given two integers n and k, return all possible combinations of k numbers out of 1 ... n.

Example:

Input: n = 4, k = 2
Output:
[
  [2,4],
  [3,4],
  [2,3],
  [1,2],
  [1,3],
  [1,4],
]

Solution: ----------------------------------- Backtracking ------------------------ https://www.youtube.com/watch?v=qzdTZWW1X8A
class Solution(object):
    def combine(self, n, k):
        res = []
        currlist = []
        stack_number = 1
        self.combine_help(n, k, currlist, stack_number, res)
        return res
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
    def combine_help(self, n, k, currlist, stack_number, res):
        if k == 0:                  # Exiting Condition
            res.append(currlist[:])
        else:
            for i in range(stack_number, n + 1):
                currlist.append(i)
                self.combine_help(n, k - 1, currlist, i + 1, res)
                #it must be "i + 1" instead of "stack_number + 1" inside a for loop with i
                currlist.pop()     
                # Remember to remove the add element and leave the space afterward
                
More concise version:
class Solution(object):
    def combine(self, n, k):
        if n < 0:
            return[]
        if k <= 0:
            return[[]]
        res = []
        self.backtracking_help(n, k, 1, [], res)
        return res
        """
        :type n: int
        :type k: int
        :rtype: List[List[int]]
        """
    def backtracking_help(self, n, k, idx, path, res):
        if len(path) == k:
            res.append(path[:])
            return
        for i in range(idx, n + 1):
            self.backtracking_help(n, k, i + 1, path + [i], res) # IMPORTANT!!!!!!!!!! here should be "i + 1" instead of "idx + 1"
                                                                 # the idx need to be updated according to i instead of idx itself!!!!!
